<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Factorish: The Twelve-Fakter App</title>

		<meta name="description" content="The Twelve-Fakter App">
		<meta name="author" content="Paul Czarkowski">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/simple.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-35638296-2', 'auto');
  ga('send', 'pageview');

</script>
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Factorish: The Twelve-Fakter App</h2>
					<h3><a href="http://factorish.github.io/factorish">http://factorish.github.io/factorish</a></h3>
					<p><img src="images/tofurkey.jpg"><br><small>http://www.tofurky.com/</small><br>
					<p>
						<small>Created by <a href="http://tech.paulcz.net">Paul Czarkowski</a> / <a href="http://twitter.com/pczarkowski">@pczarkowski</a></small>
					</p>
				</section>

				<section>
					<h2>Who am I</h2>
 					<p><img src="images/sysadmin.jpg"><br>
 					<p>Cloud Engineer @ Bluebox
 					<aside class="notes">
 					* I am a sysadmin<br>
 					* get called rude names like cloud engineer or devop<br>
 					</aside>
				</section>

				<section>
					<h2>Bluebox</h2>
 					<p><img src="images/private_cloud.png"><br>
 					<h2>Shameless Plug</h2>
 					<aside class="notes">
 					* I work at bluebox on the openstack team<br>
 					* we do PCaaS.  running PC is hard, we're here to do it for you.
 					* cloud / api driven infrastructure makes it easier to do dynamic apps / dockers
 					</aside>
				</section>

				<section>
					<h2>Factorish: The Twelve-Fakter App</h2>
						<p><img src="images/donkey-carrot.png">
 					<aside class="notes">
 					* lot of noise in docker community about how to docker<br>
 					* single process, small images, etc.<br>
 					* mostly bullshit.<br>
 					* factorish is my way to bring some pragmatism to this mess.
 					</aside>
				</section>

				<section>
					<h2>The Twelve-Factor App</h2>
					<h3><a href="http://12factor.net">12factor.net</a></h3>
						<p><img src="images/unicorn.jpg"><br><small>http://www.foodbeast.com/news/move-over-horsemeat-unicorn-cuts-are-all-the-rage/</small>
 					<aside class="notes">
 					Is everyone familiar with the concept of 12 factor apps?<br>
 					</aside>
				</section>

				<section>
					<h2>The Twelve-Factor App</h2>
					<h3><a href="http://12factor.net">12factor.net</a></h3>
					<br>
					<h4>A methodology for building modern web apps that:</h4>
					<br><br>
 					<ul>
 						<li>Use declarative formats for setup automation
 						<li>Have a clean contract with the underlying operating system
 						<li>Are suitable for deployment on modern cloud platforms
 						<li>Minimize divergence between development and production
 						<li>And can scale up without significant changes
 					</ul>
 					<aside class="notes">
 					* 12 factor is a manifest of how to write applications in the new cloudy / microservices way.<br>
 					* TLDR of 12factor is 'this is how to write apps to run on heroku'<br>
 					* even if not docker/heroku, think about 12factor when writing apps/CM.
 					</aside>
				</section>

  			<section>
					<h2>The Twelve-Factor App</h2>
					<h3>Dockerized</h3>
						<p><img src="images/unicorn_meat.jpg"><br><small>http://www.thinkgeek.com/product/e5a7/?srp=2</small>
 					<aside class="notes">
 					* grind up unicorn meat and pack it into container to ship it around.
 					</aside>
				</section>

				<section>
					<h2>Your App</h2>
						<p><img src="images/donkey-cart.jpg"><br>
 					<aside class="notes">
 					* meanwhile the rest of us have apps that look like this<br>
 					* not only is it decidely not a unicorn, but is weighed down by baggage
 					</aside>
				</section>

				<section>
						<p><img height="200%" width="200%" src="images/willitdocker.gif">
 					<aside class="notes">
 					* so take your app and ask yourself ...  WILL IT DOCKER?<br>
 					* with Factorish the answer is *probably*
 					</aside>
				</section>

				<section>
					<h2>Your App</h2>
					<br>
					<h4>A decade old application that sort of still runs.</h4>
					<br><br>
 					<ul>
 						<li>Runs on servers that are lovingly hand crafted.
 						<li>Is written in a outdated language with poor dependency resolution.
 						<li>Runs under a web server like Apache or Tomcat.
 						<li>Looks different in Development and Production (and all the other steps).
 					</ul>
 					<aside class="notes">
 					* Your app has probably been around for a while<br>
 					* some of it might be CM. <br>
 					* hand deployed to production <br>
 					* development not like production
 					</aside>
				</section>

				<section>
					<h2>The Twelve-Fakter App</h2>
					<h3>Dockerized</h3>
						<p><img src="images/spam_can_open.jpg"><br><small>http://tastyislandhawaii.com/2007/12/07/tulip-vs-treet-vs-spam-musubi-showdown/</small>
 					<p>The Container is your app
 					<aside class="notes">
 					* however we can grind it up into a paste and put it in a container.<br>
 					* aside from the label, can't tell it apart from unicorn.<br>
 					* the container is our app ( or at least our built artifact / executable ).
 					</aside>
				</section>

				<section>
					<h2>The Twelve-Fakter App</h2>
						<p><img src="images/emoji_poop.png">
 					<aside class="notes">
 					* polishing a turd ... but a turd that makes you money!<br>
 					* there might be a poo in the box,  but from the outside it looks like unicorn!
 					</aside>
				</section>

				<section>
					<h2>But Why ?</h2>
					<br>
 					<ul>
 						<li>You want to modernize your application.
 						<li>You probably can't <i>fix</i> the app.
 						<li>No time to rewrite the app.
 					</ul>
 					<aside class="notes">
 					* have an app, it makes money, but its hard to run, hard to maintain.<br>
 					* you like the idea of runtime configured immutable application.<br>
 					* bimodal IT,  think towards future.<br>
 					* slow introduces your org to a new way of doing things.<br>
 					* CM + Docker is not big shift as all docker all time with dyn.<br>
 					* lets talk through the 12factors and talk about how to fake it.<br>
 					</aside>
				</section>

				<section>
				  <h2>Fakter I. Codebase</h2>
				  <h4>One codebase tracked in revision control, many deploys</h4><br><br>
				  <ul>
				    <li>Use Source control ( GIT! )
				    <li>Add these to your app (or make them your app)
				    <ul>
				    <li>Dockerfile / .dockerignore
				    <li>Vagrantfile
				    <li>Deploy scripts
				    </ul>
				    <li>https://github.com/paulczar/factorish
				  </ul>
 					<aside class="notes">
 					* Factor 1 is all about having your code and everything required to run your code in source control.<br>
 					* scripts ( cookbooks etc ) to build, deploy, and run your code.  share versioning.<br>
 					* vagrantfile to ensure everyone has exact same experience.<br>
 					* Factorish is designed to be copy/paste able into your code base with minimal change.
 					</aside>
				</section>

				<section>
				  <h2>Fakter II. Dependencies</h2>
				  <h4>Explicitly declare and isolate dependencies</h4><br><br>
				  <ul>
				    <li>Declaration: Dockerfile
				    <li>Isolation: `docker build`
				  </ul>
				  <br><br>
 					<aside class="notes">
 					* Factor 2 tells us that all deps should be declared and isolated.<br>
 					* declares all dependencies, completely and exactly, not reliance on system packages<br>
 					* dependency isolation - tool run during build to ensure that no implicit dependencies 'leak in' <br>
 					* Ruby, `gemfile` is declaration,  `bundle install` is isolation.<br>
 					* Docker, `Dockerfile` is declaration, `docker build` is isolation. - can rely on system packages.
 					</aside>
				</section>

				<section>
				  <h2>Fakter II. Dependencies</h2>
				  <pre class='stretch'><code>
# Dockerfile: factorish/example
FROM python:2
MAINTAINER Paul Czarkowski "paul@paulcz.net"
RUN \
  apt-get update && apt-get install -yq
  supervisor \
RUN \
  curl -sSL -o /usr/local/bin/etcdctl https://s3-us-west-2.amazonaws.com/opdemand/etcdctl-v0.4.6 && chmod +x /usr/local/bin/etcdctl \
  && curl -sSL -o /usr/local/bin/confd https://github.com/kelseyhightower/confd/releases/download/v0.7.1/confd-0.7.1-linux-amd64 && chmod +x /usr/local/bin/confd
ADD . /app
WORKDIR /app
RUN \
  useradd -d /app -c 'application' -s '/bin/false' app && \
  chmod +x /app/bin/* && \
  pip install -r /app/example/requirements.txt
CMD ["/app/bin/boot"]
EXPOSE 8080
				  </code></pre>
				</section>

				<section>
				  <h2>Fakter III. Configuration</h2>
				  <h4>Store config in the environment</h4><br><br>
				  <p><b>Again, Easy wins with Docker</b></p>
				  <ul>
				    <li>`docker run -e TEXT=bacon myapp`
				    <li>Confd - {{ getv "/text" }}
				    <li>`sed -i "s/xxxTEXTxxx/${TEXT}" /etc/config.conf`
				  </ul>
 					<aside class="notes">
 					* According to factor 3, all configuration should be done via environment<br>
 					* Can I opensource this code without compromising secrets / passwords ?<br>
 					* internal application config that doesn't change between envs should remain in code.
 					</aside>
				</section>

				<section>
				  <h2>Fakter III. Configuration</h2>
<p>/app/conf.d/example.conf.toml
				  <pre><code>
[template]
src   = "example.conf"
dest  = "/app/example/example.conf"
owner = "app"
group = "app"
mode  = "0644"
keys = [
  "/services/example",
]
check_cmd = "/app/bin/check {{ .src }}"
reload_cmd = "supervisorctl restart example"
				  </code></pre>
<p>/app/templates/example.conf
				  <pre><code>
[example]
text: {{ getv "/services/example/text" }}
				  </code></pre>
				<p>{{ }} - golang/confd macro syntax.
				</section>

				<section>
				  <h2>Fakter IV. Backing Services</h2>
				  <h4>Treat backing services as attached resources</h4><br><br>
				  <ul>
				    <li>Make no distinction between local and third party services.
				    <li>use ENV to configure.
				    <li>Fairly simple to manage for databases etc.
				    <li>disk persistence is the hard one.
  			    <ul>
				      <li>Docker: volume mounts*, data containers, flocker
				      <li>Remote Storage: netapp, nfs, fuse-s3fs
				      <li>Clustered FS: drdb, gluster
				      <li>Ghetto: rsync
				   </ul>
				  <p>* security implications.
 					<aside class="notes">
 					* A backing service is any service the app consumes over the network as part of its normal operation<br>
 					* no distinction between local and third party services ... i.e. local mysql db = rds<br>
 					* ofc do have to manage that servce, but outside pervue of your app.<br>
 					* change out backing services without code change ( change env variable! )<br>
 					* disk persistence is hard
 					</aside>
				</section>

				<section>
				  <h2>Fakter IV. Backing Services</h2>
					<p>/app/templates/wp-config.php
				  <pre><code>
/** The name of the database for WordPress */
define('DB_NAME', '{{ getv "db/name" }}');

/** MySQL database username */
define('DB_USER', '{{ getv "db/user" }}');

/** MySQL database password */
define('DB_PASSWORD', '{{ getv "db/pass" }}');

/** MySQL hostname */
define('DB_HOST', '{{ getv "db/host" }}');
			  </code></pre>
			  <p>Docker Run command
				  <pre><code>
$ docker run -d -e DB_NAME=wordpress -e DB_USER=wordpress \
  -e DB_PASSWORD=wordpress $DB_HOST=my.database.com \
  -v /mnt/nfs/wordpress:/app/wordpress factorish/wordpress
				  </code></pre>
				</section>

				<section>
				  <h2>Fakter V. Build, release, run</h2>
				  <h4>Strictly separate build, release and run stages</h4><br><br>
				  <ul>
				    <li>Build: `docker build -t myapp:base .`
				    <li>Release: `docker build -t myapp:v1.3.2 .`
				    <li>Run: `docker run -d myapp:v1.3.2`
				    <br><br>
				    <li class="fragment">Release/Run: `docker run -d -e TEXT=bacon myapp:base`
				  </ul>
 					<aside class="notes">
* The build stage takes your code repo at a specific git release and converts it into an executable bundle known as a build.  It fetches and vendors dependencies and compiles binaries and assets.<br>
* The release stage takes this build and combines it with the deploy’s current config. The resulting release contains both the build and the config and is ready for immediate execution. - versions, docker registry, rollback - free with paas<br>
* The run stage runs the app in the execution environment by launching one or more processes against a selected release<br>
* IMO its okay to combine Release/Run steps in a docker based environment. - but do lose some rollback capability.
 					</aside>
				</section>

				<section>
				  <h2>Fakter VI. Processes</h2>
				  <h4>Execute the app as one or more stateless processes</h4><br><br>
				  <ul>
				    <li>Applications should be treated as stateless processes.
				    <li>All data that needs to be persisted should be done via backing services.
				    <li>example: `session` data stored in redis or memcache.
				  </ul>
 					<aside class="notes">
 					* No state should be persisted to disk by the application, rather sent to a backing service.<br>
 					* example storing session data in redis or memcache.<br>
 					* App can use local mem or disk for short lived transactional cache.<br>
 					* Sticky sessions are bad, do not use them, or live with the consequences.
 					</aside>
				</section>

				<section>
				  <h2>Fakter VII. Port binding</h2>
				  <h4>Export services via port binding</h4><br>
				  <ul>
				    <li>Use a language specific webserver library like `jetty` for java if possible.
				    <li>Usually relying on an external webserver (ex. nginx for php) is a violation of 12factor.
				    <li>Port Binding: <b>EXPOSE</b> in Dockerfile, or <b>$ docker run -p 8080:8080</b>.
				    <li>any app can be used as a backing app for another app.
				  <br><br>
				  <p>
 					<aside class="notes">
 					* 12factor app is completely self contained and does not rely on an external webserver like apache.  However since our application is the container, its okay if you have to use a webserver inside the container.<br>
 					* Note also that the port-binding approach means that one app can become the backing service for another app, by providing the URL to the backing app as a resource handle in the config for the consuming app.
 					</aside>
				</section>

				<section>
				  <h2>Fakter VIII. Concurrency</h2>
				  <h4>Scale out via the process model</h4><br>
				  <ul>
				    <li>assign each type of work to a process type ( container! )
				    <li>Your application should not daemonize or write pid files.
				    <ul>
				      <li>if it does, you may be able to script around it.
				      <li>Apps like nginx and apache can be run in foreground.
				    </ul>
				    <li>Utilize tools like runit or supervisord to handle process management.
				    <li>Horizonal vs Vertical scaling.
  			  </ul>
 					<aside class="notes">
 					* Try to break up functionality of monolithic app into seperate containers/processes, each doing a specific task.<br>
 					* One container serves web requests, another processes images into thumbnails.<br>
 					* In the twelve-factor app, processes are <i>the</i> first class citizen.<br>
 					* Try to avoid daemonizing,  always want to run process in foreground.<br>
 					* VM/Phys can only grow so much, by having multiple containers we can now have multiple VMs.
 					</aside>
				</section>

				<section>
				  <h2>Fakter IX. Disposability</h2>
				  <h4>Maximize robustness with fast startup and graceful shutdown</h4><br>
				  <ul>
				    <li>Otimize to minimize startup ( Docker helps with this! )
				    <li>Graceful shutdown ( Finish current reqs or give back to a queue )
				    <li>Sudden Death ( minimal impact on crash.  Smart LB can help? )
  			  </ul>
 					<aside class="notes">
 					* All processes/containers should be disposable. stated or stopped at a moments notice<br>
 					* When a container gets SIGTERM, apps inside should gracefully shut down.<br>
 					* most web connections are brief, is it a big deal if you lose a few on Sudden death ?  Be OK with small amounts of broken connections.
 					</aside>
				</section>

				<section>
				  <h2>X. Dev/prod parity</h2>
				  <h4>Keep development, staging, and production as similar as possible</h4><br>
				  <p>You've already done most of the work to achieve this:
				  <ul>
				    <li>Use Vagrant or Docker Compose to deploy your app <i>and</i> backing services in dev environment using appropriate provisioners.
				    <li>Docker helps reduce time to go from dev to prod with portable/immutable artifacts.
				    <li>by deploying all envs with same tooling, every dev rebuilt is a test of prod deploy tooling.
				    <li>Actions to deploy to prod should be very similar to deploy to dev.
  			  </ul>
 					<aside class="notes">
 					* If you've gotten this far, we've already accomplished just about everything required here.<br>
 					* it's mostly okay to use a mysql container in dev and RDS in prod.  mysql ~= mysql.<br>
 					* Docker-Compose is excellent for chaining together backing services, be wary of links.<br>
 					* Traditional CM is also perfect here.  For example using chef to build backing services and deploying container.
 					</aside>
				</section>

				<section>
				  <h2>XI. Logs</h2>
				  <h4>Treat logs as event streams</h4><br>
				  <ul>
				    <li>Never write to a log file always to stdout ( /dev/stdout /dev/stderr are your friends)
				    <li>If you <B>have</B> to write to a log file, you're violating several rules and will have to try to
				    script around it (or use a remote file backing service) so that long running containers do not run out of disk space.
				    <li>By writing to stdout, docker log subsystem sees the logs, and then tooling like ``logspout` can utilize to forward stream to central location.
  			  </ul>
 					<aside class="notes">
 					* super important! otherwise need log management in container.<br>
 					* if absolutely can't avoid writing logs, use a volume mount or a syslog in the container.<br>
 					* Set a self destruct timer.
 					</aside>
				</section>

				<section>
				  <h2>XII. Admin processes</h2>
				  <h4>Run admin/management tasks as one-off processes</h4><br>
				  <p><b>Docker</b></p>
				  <ul>
				    <li>docker run -t -e TEXT=bacon myapp:1.3.2 rake db:migrate or
				    <li>docker exec -t vibrating_descartes rake db:migrate
				  </ul>
 					<aside class="notes">
 						* never ssh to a running container to do one off tasks<br>
 						* best to create a new container to run the task and then die.<br>
 						* most PaaS have a way to do that.<br>
 						* can use docker exec to run it inside an existing container,  but try to avoid.

 					</aside>
				</section>

				<section data-background="images/scoutapark.jpg" data-background-size="1400px">
					<h2>Demo - Scoutapark</h2>
					<p><a href="http://scoutapark.com/">http://scoutapark.com</a></p>
 					<aside class="notes">
 					 * scoutapark, startup, dan is not dev, php = cheap labor for MVP<br>
 					 * walkthrough it, then walkthrough factorish.<br>
 					 * demo both<br>
 					</aside>
				</section>

				<section>
					<h2>Demo - Factorish</h2>
					<p><a href="https://github.com/factorish/factorish">https://github.com/factorish/factorish</a></p>
 					<aside class="notes">
 					 * scoutapark, startup, dan is not dev, php = cheap labor for MVP<br>
 					 * walkthrough it, then walkthrough factorish.<br>
 					 * demo both<br>
 					</aside>
				</section>

   			<section>
					<h2>Links</h2>
					<br><br>
					<ul>
					<li><a href="factorish.github.io/factorish">This Presentation</a>
					<li><a href="http://tech.paulcz.net/2015/01/factorish_and_the_12_fakter_app/">Blog post on factorish/12fakter</a>
					<li><a href="http://tech.paulcz.net/2015/01/factorish_and_the_12_fakter_app/">This Presentation</a>
					<li><a href="https://github.com/factorish/factorish">Factorish @ github</a>
					<li><a href="https://github.com/factorish/factorish-elk">Factorish - ELK</a>
 					<aside class="notes">
 					</aside>
				</section>

  			<section>
					<h1>THE END</h1><br><br>
					<h3>BY Paul Czarkowski  / <a href="http://twitter.com/pczarkowski">@pczarkowski</a> </h3>
 					<aside class="notes">
 					</aside>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
